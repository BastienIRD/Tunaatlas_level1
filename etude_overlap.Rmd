---
title: "Etude de l'overlap"
output: html_document
date: '2022-03-14'
params:
  chemin_dacces: "~/Documents/Tunaatlas_level1/jobs/20220331130831/entities/global_catch_ird_level1/Markdown/overlapiccat_ccsbt/rds.rds"
  plotting: "view"
---

```{r setup, include=FALSE}
#data/Les7entites_finies/entities/global_catch_5deg_1m_firms_level0/Rds/georef_dataset_level0_step11global_catch_5deg_1m_firms_level0.rds"
#data/Les7entites_finies/entities/5deg_level1_reallocate/georef_dataset_step5.rds"
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
library(DBI)
library(RPostgres)
library(RPostgreSQL)
library(tmap)
library(dplyr, warn.conflicts = FALSE)
library(sf)
library(tmap)
library(tidyverse)

```


```{r}

data <- readRDS(params$chemin_dacces)
  data <- data%>% mutate(unit = case_when(unit %in% c("MT","t","MTNO", "Tons")~ "Tons", unit %in% c("no", "NOMT", "Number of fish", "NO")~"Number of fish"))


drv <- dbDriver("PostgreSQL")      
con <- DBI::dbConnect(drv , dbname = "tunaatlas", host = "db-tunaatlas.d4science.org", 
                      port = 5432,
                      user = "tunaatlas_u",
                      password = "21c0551e7ed2911")


query <- "SELECT  code,st_area(geom), geom from area.cwp_grid"
world_sf <- st_make_valid(st_read(con, query = query))%>% filter(!st_is_empty(.))

query_area <- paste0("SELECT * FROM area.rfmos_convention_areas_fao")
competence_area <- st_make_valid(st_read(con, query = query_area)) %>% filter(!st_is_empty(.))
IOTC <- competence_area %>% filter(code == "IOTC")
IATTC <- competence_area %>% filter(code == "IATTC")
WCPFC <- competence_area %>% filter(code == "WCPFC")
ICCAT <- competence_area %>% filter(code == "ICCAT")
continent <- st_read(
  "data/continent.shp")

IOTC <- world_sf[IOTC,]%>% st_set_geometry(NULL) %>% mutate(iotc = "iotc")
IATTC <- world_sf[IATTC,]%>% st_set_geometry(NULL) %>% mutate(iattc = "iattc")
WCPFC <- world_sf[WCPFC,]%>% st_set_geometry(NULL) %>% mutate(wcpfc = "wcpfc")
ICCAT <- world_sf[ICCAT,]%>% st_set_geometry(NULL) %>% mutate(iccat = "iccat")



full_join <- full_join(full_join(full_join(full_join(world_sf, IOTC), IATTC), WCPFC), ICCAT) %>% st_set_geometry(NULL) 


full_join[is.na(full_join)] <-  FALSE

full_join <- full_join %>% mutate(area_competence = as.factor(gsub("FALSE","",paste0(iotc, iattc, wcpfc, iccat))))

# world_sf$iotc <-as.logical(floor((st_within(world_sf,IOTC) %>% lengths >0) + (st_intersects(world_sf,IOTC)%>% lengths >0) /2))
# world_sf$iattc <- as.logical(floor((st_within(world_sf,IATTC) %>% lengths >0) + (st_intersects(world_sf,IATTC)%>% lengths >0) /2))
# world_sf$wcpfc <- as.logical(floor((st_within(world_sf,WCPFC) %>% lengths >0) + (st_intersects(world_sf,WCPFC)%>% lengths >0) /2))
# world_sf$iccat <- as.logical(floor((st_within(world_sf,ICCAT) %>% lengths >0) + (st_intersects(world_sf,ICCAT)%>% lengths >0) /2))

world_sf$continent <- st_within(world_sf, continent) %>% lengths > 0 
world_sf$continent <- str_replace(world_sf$continent, "TRUE","continent")

world_sf <- left_join(world_sf, full_join)


# for (i in 4:length(world_sf)) {
#     world_sf[[i]] <- str_replace(world_sf[[i]], "TRUE", colnames(world_sf)[i])
# }

test <- world_sf %>% mutate(area_competence = as.factor(gsub("FALSE","",paste0(iotc, iattc, wcpfc, iccat, continent))))

# df <- st_as_sf(inner_join(world_sf %>% as.data.frame() %>% select(-geom), test ,by = "code"))
inner_join <- data %>% inner_join(world_sf, by = c("geographic_identifier"="code"))


test <- inner_join  %>% ungroup() %>% group_by(geographic_identifier, st_area, unit, source_authority) %>% summarise(value= sum(value, na.rm = TRUE))%>% distinct() %>% inner_join(world_sf , by = c("geographic_identifier"="code", "st_area")) %>% select(geographic_identifier, st_area, value, geom, unit, source_authority, area_competence)

mislocated_continent <- test %>% filter(area_competence == "continent")
if (nrow(mislocated_continent)==0){knitr::knit_exit()}
tmap_mode(params$plotting)

tm_shape(st_as_sf(mislocated_continent %>% mutate(st_area = as.factor(st_area))))+tm_fill("value")+tm_facets(by=c("st_area","unit"))+tm_text("source_authority")+tm_shape(continent)+tm_borders() 

# tm_shape(df)+tm_polygons(col = "area_competence")+tm_facets("st_area.x")
# test3 <- inner_join %>% mutate(continent = ifelse(area_competence.x != "continent", "ocean", "continent"))
# # summary(test3)
# tm_shape(test3 %>% mutate(st_area = as.factor(st_area.x.x)) %>% filter(continent == "continent"))+tm_polygons(col = "value")+tm_facets("st_area")+tm_shape(continent)+tm_borders()



```

# Distribution of mislocated data 

```{r}

test2 <- test %>% group_by(unit) %>% group_by(unit, source_authority) %>% arrange(desc(source_authority)) %>% summarise(value = sum(value, na.rm = TRUE))  %>% ungroup() %>% group_by(unit) %>%  mutate(pourcentage = prop.table(value)*100)%>%
    mutate(labels = paste0(pourcentage," ",  " % "))%>% arrange(desc(source_authority)) %>% 
  mutate(ypos_ligne = cumsum(pourcentage)- 0.5*pourcentage ) %>%
    distinct()
ggplot(test2) +aes(
    x = "",
    fill = source_authority,
    colour = source_authority,
    group = source_authority,
    weight = pourcentage
  ) +
  geom_bar(position = "fill") +
  scale_fill_hue(direction = 1) +
  scale_color_hue(direction = 1) +
  theme_minimal()+ coord_polar("y", start=0)+ geom_text(data = (test2 %>% mutate_if(is.numeric, round)), size = 3,
                           aes( x = 1 ,y = ypos_ligne/100, label = paste0(pourcentage,"%")), color = "black")+
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank())+
  labs(x = "", y="") + facet_wrap("unit")

```


***This markdown is aimed to study the repartition of each unity for a specific dataset, in this case is `r params$chemin_dacces`.***

```{r}
test3 <- test %>% mutate(continent = ifelse(area_competence != "continent", "ocean", "continent"))

```


```{r}
# st_geometry(test3) <- NULL
final <- test3 %>% group_by(continent, unit) %>% summarise(value = sum(value))
# test2_without_continent <- test %>% filter(area_competence != "continent")
# value_without_continent <- sum(test2_without_continent$value, na.rm =TRUE)

en_nombre_continent <- pull(final %>% filter(unit == "Number of fish") %>% filter(continent == "continent"))
en_nombre_ocean <- pull(final %>% filter(unit == "Number of fish") %>% filter(continent == "ocean"))
en_tonne_continent <- pull(final %>% filter(unit == "Tons") %>% filter(continent == "continent"))
en_tonne_ocean <- pull(final %>% filter(unit == "Tons") %>% filter(continent == "ocean"))

perte_en_nombre <- (en_nombre_continent / (en_nombre_ocean+en_nombre_continent))*100
perte_en_tonne <- (en_tonne_continent/ (en_tonne_continent+en_tonne_ocean))*100

# value_with_continent <- sum(test$value, na.rm = TRUE)

# perte_en_pourcent_conitnent <- ((value_with_continent-value_without_continent)/value_with_continent)*100
```

Removing the data placed on the continents, the losses at the end of level 0 amount to `r perte_en_nombre` % in number and `r perte_en_tonne` % in tons. 

We are now interested in the mislocated data

```{r}

mislocated <- inner_join %>%filter(area_competence!="continent") %>%  ungroup() %>% select(area_competence, source_authority, value, unit, geom) %>% mutate(area_competence = toupper(area_competence)) %>%  mutate(mislocated = case_when(source_authority =="CCSBT" ~TRUE, area_competence%in%c("IATTC", "ICCAT", "IOTC", "WCPFC") & area_competence == source_authority ~ TRUE,
                              area_competence == "IOTCWCPFC" & source_authority %in% c("IOTC", "WCPFC")  ~ TRUE,
                              area_competence == "IATTCWCPFC" & source_authority %in% c("IATTC", "WCPFC")  ~ TRUE, tolower(area_competence) == area_competence ~ TRUE, 
                              TRUE ~ FALSE))

final <- mislocated %>% group_by(mislocated, unit) %>% summarise(value = sum(value))
en_nombre_false<- pull(final %>% filter(unit == "Number of fish") %>% filter(mislocated == FALSE))
en_nombre_true <- pull(final %>% filter(unit == "Number of fish") %>% filter(mislocated == TRUE))
en_tonne_false <- pull(final %>% filter(unit == "Tons") %>% filter(mislocated == FALSE))
en_tonne_true <- pull(final %>% filter(unit == "Tons") %>% filter(mislocated == TRUE))

perte_en_nombre <- (en_nombre_false / (en_nombre_true+en_nombre_false))*100
perte_en_tonne <- (en_tonne_false/ (en_tonne_false+en_tonne_true))*100


```

```{r eval=FALSE}
tm_shape(IOTC)+tm_fill(alpha = 0.2, col = "red")+tm_shape(IATTC)+tm_fill(alpha = 0.2, col = "yellow")+tm_shape(ICCAT)+tm_fill(alpha = 0.2, col = "purple")+tm_shape(WCPFC)+tm_fill(alpha = 0.2, col = "skyblue")+tm_shape(st_as_sf(mislocated %>% filter(mislocated ==FALSE) %>% filter(source_authority!="CCSBT")))+tm_polygons(col = "source_authority")+tm_facets("unit")
```

```{r}
tm_shape(WCPFC)+tm_borders( col = "red")+tm_shape(ICCAT)+tm_borders( col = "yellow")+tm_shape(IOTC)+tm_borders( col = "purple")+tm_shape(IATTC)+tm_borders( col = "skyblue")+tm_shape(st_as_sf(mislocated %>% filter(mislocated ==FALSE) %>% filter(source_authority!="CCSBT")))+tm_polygons(col = "source_authority")#+tm_facets("unit")
```


En retirant les données placées sur les continents, ainsi que les données d'une rfmo dans une zone hors de leur compétence, les pertes à la fin du niveau 0 s'élèvent à `r perte_en_nombre` % en nombre et à `r perte_en_tonne` % en tonnes. 
